## ebeans

### "Model not enhanced"

`ebeans` generates code as part of the [ORM](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping).  The full object, including the generated code, is referred to as "enhanced".  The generated object is injected using Guice into some database machinery.  Other terms for "enhancement" include "weaving", "transformation", and "byte code manipulation" [ref](https://ebean.io/docs/setup/enhancement).

If something goes wrong with this process, you may see an error in tests at the time that the database connection is being initiated.  It will use the words "not enhanced", and contain a list of troubleshooting steps.  The error will tell you to [install a plugin for IDEA or Eclipse](https://ebean.io/docs/trouble-shooting).  This is a red herring!  We do ebeans enhancement at build time, and that plugin is for projects which don't use a project management tool (like `sbt` or `mvn`).  The plugin performs a small portion of what `sbt` does, to enable you to click the green "build" button in your IDE - but none of the rest of our tooling will work with that, so there's no benefit, no need to do this.

The error will also tell you to check `ebeans.mf`.  We don't have that - that file is automatically generated by the play integration.  Our equivalent of that is in `conf/application.conf`, near the bottom, `ebeans.default = "models.*"`.  This step is worth doing - is your model outside of `models.*`?  If so, add your model to the list.  This is just one of the ways that the framework is highly dependent on our particular package structure, which should not be changed without good reason - you might find that strange things start happening.

The most likely cause of this issue is actually an apparently-benign issue loading the ebeans code.  The `sbt test` / `sbt run` will continue, but at the top of the output, you might see `java.lang.UnsupportedClassVersionError: Unsupported major version 59`.  This means that you've compiled the code with a higher version of the jdk than you're running it with - at *some point*.  It's not guaranteed that you're currently trying to do that - `sbt` tries to be really smart about incremental compilation, so you may have compiled it by, e.g. accidentally hitting the "build" button in Eclipse from muscle memory, possibly quite some time ago.

The best solution to this is to run `sbt clean cleanFiles`.  This is not quite a full clean - you must then delete every directory named `target` under the project root (at minimum `target/`, `project/target/`, and `project/project/target/`), then re-run a docker build / test.

## sbt

### sbt is behaving weird

Examples: it's not running tests, or it's telling you there are compiler warnings even though there aren't.

SBT has a lot of caching built in, and it doesn't always clean itself up quite right.  There is no single way to clean up the entire cache.

Try `bin/sbt clean`, and if that doesn't work you might try `rm -rf universal-application-tool-0.0.1/target/ universal-application-tool-0.0.1/project/project universal-application-tool-0.0.1/project/target universal-application-tool-0.0.1/logs/`.

You might also try `docker-compose down --remove-orphans` or `docker system prune`, if you suspect the problem might be a rogue docker container locking the sbt directory.

### IOError - could not create directory, `_global/inputStreams`

I don't know why this happens.  I have a lot of info on the symptoms and a solution that seems to work.  Solution first - run this on your host machine (not in the container).  `rm -rf universal-application-tool-0.0.1/target/*`.  Seems scary but this is just output cache stuff.  Everything works fine once you do this.

The bind mount in docker just doesn't copy subdirectories of `target/streams/`.  I can't figure out why to save my life, it makes no sense, it copies files in the `target` directory just fine, picks up changes to that directory fine.  There's no symlinks or hardlinks that it's failing to follow, as far as I can tell.  But if you delete the directory it works okay.  Google is no help - "bind mount missing subdirectory" and related searches are full of people confused about the wrong thing.  Please edit this if you figure out why - I hate mysteries!  But at least there's a fix.

## docker

### I cannot download the latest dev docker image

`bin/run-dev` pulls the latest dev image from the public registry. If for any reason, you cannot download the image, you can build it yourself locally. To build the container that runs the app, type `docker build -t uat .` Running this takes ~5 minutes, but it bakes in most of the dependencies you will need to download, so if you make a significant change to the dependencies you may want to re-build. Once the image is built, set environment variable `USE_LOCAL_UAT=1` so that `bin/run-dev` will use the image you just built.

### The docker container is not picking up my changes
The docker container no longer requires the volume mount, so it could be that you ran the container without the volume mapping.  Try adding `-v $PWD/universal-application-tool-0.0.1:/usr/src/universal-application-tool-0.0.1`.  If you're running with `docker-compose` or `bin/run-dev`, check that you're running the command from the correct directory (the root of the git repo, one directory above the `build.sbt` file).

### The tests are failing since Docker is not available inside the container
The tests run a postgres docker container for full integration testing.  We used to use an in memory database (which play supports quite well), but we stopped doing that because the in-memory database doesn't support the json types we are using as the core of our application, and we would have had to mock out the majority of our database interactions even in the integration tests.  However, this means that the tests (which run inside a docker container) need to be able to start another docker container.  This situation is called "docker in docker", and [everyone recommends against doing it](https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/) (the author of that article is the one who invented the tools to make it possible).

Instead, we cheat a little.  The docker client communicates with the docker daemon using a unix socket located at `/var/run/docker.sock`.  So, we just mount the host machine's `/var/run/docker.sock` inside the container's `/var/run`, the container's docker client communicates with the host system's docker daemon, and everything works fine.  Add the magic string `-v /var/run/docker.sock:/var/run/docker.sock` to the `docker run` invocation.

If you find yourself needing to do this during a `docker build` command - for instance because you'd like to run unit tests during container build, as we used to be able to do - you're not likely to succeed and I'd recommend finding another way to do what you need to do.  Volume mounts (which allow this end-running of docker-in-docker) are not available at container build time.

## auth

### Test `app.SecurityBrowserTest.basicOidcLogin` failed
The error message says expecting `"username@example.com"` to be contained in the html content. This is likely you have a stale `oidc-provider` docker image. Simply run `docker pull public.ecr.aws/t1q6b4h2/oidc-provider:latest` to get the latest image and try again.